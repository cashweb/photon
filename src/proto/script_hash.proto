syntax = "proto3";

package script_hash;

message BalanceRequest {
  // The script hash as bytes.
  bytes script_hash = 1;
}

message BalanceResponse {
  // Confirmed balance in Satoshi's.
  uint64 confirmed = 1;
  // Unconfirmed balance in Satoshi's.
  uint64 unconfirmed = 2;
}

message ScriptHashHistoryRequest {
  // The script hash as bytes.
  bytes script_hash = 1;
  // The start height from which to retrieve the history. 0 for the beginning of
  // time.
  uint32 start_height = 2;
  // The number of headers requested. If 0 indicates all
  // history to latest.
  uint32 count = 3;
}

message ScriptHashHistoryResponse {
  // Each confirmed transaction is a message:
  message HistoryItem {
    // The integer height of the block the transaction was confirmed in.
    uint32 height = 1;
    // The transaction hash as bytes.
    bytes tx_hash = 2;
  }
  repeated HistoryItem items = 1;
}

message MempoolRequest {
  // The script hash as bytes.
  bytes script_hash = 1;
}

message MempoolResponse {
  message MempoolItem {
    // The transaction hash as bytes.
    bytes tx_hash = 1;
    // The transaction fee in Satoshi's.
    uint64 fee = 2;
    // Heights of the input transactions. 0 if the input is unconfirmed.
    repeated uint32 heights = 3;
  }
  repeated MempoolItem items = 1;
}

message ListUnspentRequest {
  // The script hash as bytes.
  bytes script_hash = 1;
}

message ListUnspentResponse {
  message UnspentItem {
    // The integer height of the block the transaction was confirmed in. 0 if
    // the transaction is in the mempool.
    int32 height = 1;
    // The output’s transaction hash as bytes.
    bytes tx_hash = 2;
    // The zero-based index of the output in the transaction’s list of outputs.
    uint32 v_out = 3;
    // The output’s value in Satoshi's.
    uint64 value = 4;
  }
  repeated UnspentItem items = 1;
}

message SubscribeScriptHashRequest {
  // The script hash as bytes.
  bytes script_hash = 1;
}

message SubscribeScriptHashResponse {
  // The confirmed status of the script hash. This is the tip of the chain of
  // transaction hashes relevant to this script hash, in height then
  // lexicographical order.
  bytes confirmed_status = 1;
  // The unconfirmed status of the script hash. This is the hash of the
  // concatenation of mempool transactions in lexicographical order.
  bytes unconfirmed_status = 2;
}

message ScriptHashExtendedStatusResponse {
  bytes status = 1; //< same as the SubscribeScriptHashResponse.status above
  int32 num_tx = 2; //< the number of transactions total (including mempool)
  repeated ScriptHashStatusChunk chunks = 3;
}

message ScriptHashStatusChunk {
  // the hash as in the old ElectrumX status_hash just for the tx's in this
  // chunk
  bytes status = 1;
  // The number of tx's in this chunk. Note that usually the server will attempt
  // to chunk the statuses in groups of 100 or 1000 or whatever that particular
  // server is configured for, but if it cannot do so because some block height
  // contains many tx's, this number may not be the same for each chunk.
  int32 num_tx = 2;
  // the blockchain height of the first tx in this chunk. Except the last chunk
  // of mempool items which will have this field set to -1.
  int32 start_height = 3;
  // the blockchain height of the last tx in this chunk. Note that the next
  // chunk will necessarily have its .start_height be > this.end_height, except
  // for the mempool chunks at the end which all have start_height = end_height
  // = -1
  int32 end_height = 4;
}

service ScriptHash {
  // Return the confirmed and unconfirmed balances of a script hash.
  rpc Balance(BalanceRequest) returns (BalanceResponse);
  // Return the confirmed and unconfirmed history of a script hash.
  rpc ScriptHashHistory(ScriptHashHistoryRequest)
      returns (ScriptHashHistoryResponse);
  // Return the unconfirmed transactions of a script hash.
  rpc Mempool(MempoolRequest) returns (MempoolResponse);
  // Return an ordered list of UTXOs sent to a script hash.
  rpc ListUnspent(ListUnspentRequest) returns (ListUnspentResponse);
  // Subscribe to a script hash.
  rpc SubscribeScriptHash(SubscribeScriptHashRequest)
      returns (stream SubscribeScriptHashResponse);
  // Gets the status chunks for a script hash so the client may figure out where
  // the server and client histories differ (in the case where the initial
  // subscribe response returns a novel scripthash status to the client).
  rpc ScriptHashExtendedStatus(SubscribeScriptHashRequest)
      returns (ScriptHashExtendedStatusResponse);
}
