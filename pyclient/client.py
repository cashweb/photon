#!/usr/bin/env python3
#
# Python Photon Client, WIP
#
# Requires grpclib:
#   $ pip3 install --user grpclib protobuf
# To compile protobuf files, you can use protoc from the grpcio-tools package:
#   $ pip3 install --user grpcio-tools
# To compile the protobuf files for this, copy or link the .proto files to protos/ subdir then:
#   $ python3 -m grpc_tools.protoc -I. --python_out=. --python_grpc_out=. protos/whatever.proto
#
import asyncio
import queue
import sys
import threading
import time

from typing import Any, Callable, Tuple, Union

from grpclib.client import Channel

import google.protobuf.empty_pb2
Empty = google.protobuf.empty_pb2.Empty()

# generated by protoc
from protos import utility_pb2 as pb  # testing
from protos import utility_grpc as gr  # testing


class Client:
    DEFAULT_HOST = '127.0.0.1'
    DEFAULT_PORT = 50051  # fixme

    def __init__(self, host: str = DEFAULT_HOST, port: int = DEFAULT_PORT, ssl: bool = False,
                 *, logger: Callable = None, dont_raise_on_error=False):
        self.logger = logger or (lambda *args, **kwargs: None)
        self.host_port = (host, port)
        self.ssl = ssl
        self.thr = None
        self.utility: gr.UtilityStub = None
        self.loop = None
        self.dont_raise_on_error = dont_raise_on_error

    def start(self):
        if (self.thr and self.thr.is_alive()) or (self.loop and self.loop.is_running()):
            raise RuntimeError('Already running')
        self.loop = asyncio.new_event_loop()
        self.thr = threading.Thread(target=self._thrdFunc, daemon=True,
                                    name=f"{__class__.__name__} {':'.join([str(x) for x in self.host_port])} (id:{id(self):x}) Async Thr")
        self.thr.q = queue.Queue()
        self.thr.start()
        exc = self.thr.q.get(timeout=10.0)  # wait for thread to start before we return
        del self.thr.q
        if isinstance(exc, Exception):
            raise exc
        return True

    def stop(self):
        if not self.thr:
            return False
        if self.loop.is_running():
            self.logger("Stopping loop...")
            for task in asyncio.Task.all_tasks(self.loop):
                task.cancel()
            self.loop.call_soon_threadsafe(self.loop.stop)
        if self.thr.is_alive():
            self.logger("Waiting for thread...")
            self.thr.join()
        self.loop = self.thr = None
        return True

    def is_running(self):
        return bool(self.loop and self.loop.is_running())

    def _thrdFunc(self):
        t0 = time.time()
        try:
            self.logger("thread started: ", threading.current_thread().name)
            asyncio.set_event_loop(self.loop)
            channel = Channel(*self.host_port, loop=self.loop, ssl=self.ssl)
            self.utility = gr.UtilityStub(channel)
            self.thr.q.put(True)
            self.loop.run_forever()
        except Exception as e:
            self.thr.q.put(e)
        finally:
            self.logger("Closing channel...")
            channel.close()
            self.logger("Shutting down asyncgens...")
            self.loop.run_until_complete(self.loop.shutdown_asyncgens())
            self.loop.close()
            if self.utility:
                self.utility = None
            self.logger(f"thread '{threading.current_thread().name}' exiting after running for {time.time()-t0:.3f} seconds")

    # CAUTION --
    #   The below methods should be run in this event loop in this class's thread.
    #   They aren't to be scheduled from code that isn't excuting in this class's thread
    #   and that isn't using this class's event loop.
    #
    async def Version(self, useragent: str, version: str) -> Tuple[str, str]:
        self.logger(f"--> Sending Version...")
        reply: pb.VersionResponse = await self.utility.Version(pb.VersionRequest(agent=useragent, version=version))
        self.logger(f"<-- Got Version:", reply.agent, reply.version)
        return (reply.agent, reply.version)

    async def Banner(self) -> str:
        self.logger(f"--> Sending Banner...")
        reply: pb.BannerResponse = await self.utility.Banner(Empty)
        self.logger(f"<-- Got Banner:", reply.banner[:80]+("..." if len(reply.banner) > 80 else ""))
        return reply.banner

    async def Ping(self) -> float:
        self.logger(f"--> Sending Ping...")
        t0 = time.time()
        await self.utility.Ping(Empty)
        elapsed = time.time()-t0
        self.logger(f"<-- Got Ping reply in {1e3*elapsed:1.3f} msec")
        return elapsed

    async def DonationAddress(self) -> str:
        self.logger(f"--> Sending DonationAddress...")
        reply: pb.DonationAddressResponse = await self.utility.DonationAddress(Empty)
        self.logger(f"<-- Got DonationAddress:", reply.address[:80]+("..." if len(reply.address) > 80 else ""))
        return reply.address

    async def Sleeper(self, delay=5.0) -> int:
        await asyncio.sleep(delay)
        import random
        return random.randint(1, 1024)

    #
    # PRIVATE ---
    #
    def _do_sync(self, coro: asyncio.Future, *, timeout=10.0, dont_raise_on_error=None) -> Any:
        ''' Helper: schedules a coroutine to run in this class's thread, on its event loop. Thread safe,
        intended to be called from outside code not running on this class's thread.  Will return the result
        syncrhonously or raise an exception on timeout or if the coroutine raised. Optionally
        `dont_raise_on_error` will suppress any exceptions and None will be returned (this is a debugging
        feature). '''
        future = asyncio.run_coroutine_threadsafe(coro, self.loop)
        dont_raise_on_error = self.dont_raise_on_error if dont_raise_on_error is None else dont_raise_on_error
        try:
            result = future.result(timeout=timeout)
        except asyncio.TimeoutError as e:
            self.logger(f'The "{coro.__name__}" coroutine took too long, cancelling the task...')
            future.cancel()
            if not dont_raise_on_error:
                raise e
        except Exception as e:
            self.logger(f'The "{coro.__name__}" coroutine raised an exception: {e!r}')
            if not dont_raise_on_error:
                raise e
        else:
            self.logger(f'The "{coro.__name__}" coroutine returned: {result!r}')
            return result

    def _do_cb(self, coro : asyncio.Future, callback, *, timeout=10.0) -> None:
        ''' Helper: schedules a coroutine to run in this class's thread, on its event loop. Thread safe.
        Can be called either from outside code not running on this class's thread, or from this class's thread.
        `callback` will be called later when the coroutine completes, passing the return value from the coroutine
        to `callback`. If the coroutine raised, then an exception will be passed to `callback`.
        If a timeout occurred, asyncio.TimeoutError will be passed to `callback`.  '''
        run_coro = (asyncio.ensure_future if threading.current_thread() is self.thr
                    else asyncio.run_coroutine_threadsafe)
        future = run_coro(coro, loop=self.loop)
        timer = None
        def done_cb(future):
            if timer:
                timer.cancel()
            if future.cancelled():
                self.logger(f'The "{coro.__name__}" coroutine was cancelled.')
                return
            callback(future.exception() or future.result())
        future.add_done_callback(done_cb)
        timer = run_coro(asyncio.sleep(timeout), loop=self.loop)
        def timeout_cb(timer):
            if timer.cancelled():
                return
            if not future.done():
                future.cancel()
                callback(asyncio.TimeoutError(f"{coro.__name__} timed out after {timeout} seconds"))
        timer.add_done_callback(timeout_cb)

    # PUBLIC -- Synchronous RPC methods
    #   The below methods are thread safe and can be called from any thread EXCEPT this class's thread.
    #   They will synchronously block until a result is ready.
    #   They will raise asyncio.TimeoutError if the timeout is exceeded
    #   May also raise whatever exception the corresponding async functions above raised (such as ConnectionRefusedError, etc).
    #
    def Version_Sync(self, useragent: str, version: str, *, timeout=10.0, dont_raise_on_error=None) -> Tuple[str, str]:
        return self._do_sync(self.Version(useragent, version), timeout=timeout, dont_raise_on_error=dont_raise_on_error)
    def Banner_Sync(self, *, timeout=10.0, dont_raise_on_error=None) -> str:
        return self._do_sync(self.Banner(), timeout=timeout, dont_raise_on_error=dont_raise_on_error)
    def Ping_Sync(self, *, timeout=10.0, dont_raise_on_error=None) -> float:
        return self._do_sync(self.Ping(), timeout=timeout, dont_raise_on_error=dont_raise_on_error)
    def DonationAddress_Sync(self, *, timeout=10.0, dont_raise_on_error=None) -> str:
        return self._do_sync(self.DonationAddress(), timeout=timeout, dont_raise_on_error=dont_raise_on_error)
    # testing...
    def Sleeper_Sync(self, delay=5.0, *, timeout=10.0) -> int:
        return self._do_sync(self.Sleeper(delay), timeout=timeout)

    # PUBLIC -- Callback-style RPC methods
    #   The below methods are thread safe and can be called from any thread including this class's thread.
    #   Callbacks will execute in the thread context of this class's thread, and will be passed the result
    #   of the corresponding _RpcXXX() function above. If the _RPC function raised, the callee will
    #   be passed the exception encountered.  If the _RPC function timed out, asyncio.TimeoutError will be passed.
    #   Otherwise the result of the RPC call will be passed to `callback`.
    #
    def Version_CB(self, callback: Callable[[Union[Tuple[str, str], Exception]], None], useragent: str, version: str, *, timeout=10.0):
        self._do_cb(self.Version(useragent, version), callback, timeout=timeout)
    def Banner_CB(self, callback: Callable[[Union[str, Exception]], None], *, timeout=10.0):
        self._do_cb(self.Banner(), callback, timeout=timeout)
    def Ping_CB(self, callback: Callable[[Union[float, Exception]], None], *, timeout=10.0):
        self._do_cb(self.Ping(), callback, timeout=timeout)
    def DonationAddress_CB(self, callback: Callable[[Union[str, Exception]], None], *, timeout=10.0):
        self._do_cb(self.DonationAddress(), callback, timeout=timeout)
    # testing...
    def Sleeper_CB(self, callback: Callable[[Union[int, Exception]],None], delay=5.0, *, timeout=10.0):
        self._do_cb(self.Sleeper(delay), callback, timeout=timeout)

if __name__ == "__main__":
    host = Client.DEFAULT_HOST
    port = Client.DEFAULT_PORT
    try:
        _host, _port = sys.argv[-1].rsplit(':', 1)
        _port = int(_port)
        host, port = _host, _port
        del _host, _port
    except:
        print(f"Note: Will connect to default {host}:{port}, specify a HOST:PORT on the command-line to override.")
    else:
        print(f"Command-line host:port specified: \"{host}:{port}\"")

    c = Client(host, port, logger=print, dont_raise_on_error=True)
    print(repr(threading.current_thread()))
    c.start()
    c.Version_Sync("Photon PyClient", "0.1.0")
    c.Banner_Sync()
    c.Ping_Sync()
    c.DonationAddress_Sync()
    def got_result(x):
        print("CB Got result:", repr(x))
        print("Thread:", repr(threading.current_thread()))
        # test scheduling another callback from within the callback.. works!
        c.Sleeper_CB(print, 1.0, timeout=0.5)
    c.Sleeper_CB(got_result, 2.0, timeout=3.0)
    time.sleep(3.0)
    c.stop()
